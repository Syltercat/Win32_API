[툴 구조 만들기]

* 툴을 만드는 이유: 데이터와 코드를 구분하기 위해, 
			  프로그래머가 아닌 각 분야에 필요한 다양한 데이터를 만들기 위해

*툴은 어떻게 만들어야 하는가?
  - 사용하기 쉽고 직관적이게
  - 사용자 위주의 인터페이스 설계 (분할 뷰, 숫자 직접입력 없이 스크롤과 버튼 등으로 동작하게)
  - 데이터가 적용된 결과를 확인할 수 있도록 제작
  - 프로젝트에 따라 툴 제작

* 툴 형태
1) 출력 화면  |  메뉴 툴
2) 출력 화면  |  다른 출력 화면  |  메뉴 툴
3) 최종 출력 화면  |  다른 출력 화면  |  다른 출력 화면  |  메뉴 툴

* 모달 다이얼로그와 모델리스 다이얼로그 차이점
  > 모달 다이얼로그 		  			> *모델리스 다이얼로그
    - 현재 다이얼 로그만 활성      			- 다른 윈도우 활성화 가능
     (일시적으로 어떤 값을 받고자 할 때 사용)	 (계속 화면에 떠있으면서 데이터를 주고 받고자 할 때 사용)
    - DialogBox()로 생성		  			- CreateDialog()로 생성
    - EndDialog()로 해제 		  		- DestroyDialog()로 해제

* 윈도우와 다이얼로그 생성
<1단계>
1) 자동 생성 코드로 윈도우 생성
2) 폼 생성: 폼 속성에서 Visible 속성값을 True로 수정
3) 다이얼로그 프로시져 코드는 About을 복사해서 사용 (안전하고 오타나 에러 줄임)
	+ 모델리스형 프로시져 복사 및 수정
	+ 확인 버튼과 취소 버튼에 관련된 코드 부분 주석처리

<2단계>
1) 기본 윈도우와 다이얼로그의 윈도우 핸들 선언과 생성, 해제 
=> 전역변수: 윈도우 프로시져와 다이얼로그의 프로시져 핸들을 서로 공유하기 위해서 사용 
2) 왼쪽 윈도우와 다이얼로그의 크기
  - 다이얼로그의 타이틀 바 제거 (굳이 필요 없기 때문에 속성: Title Bar -> false로 변경)
  - 메인 윈도우 크기를 계산
    (AdjustWindowRect() WM CREAT)
3) 윈도우 크기 변경과 위치 설정
  - WM_CREATE
  - MoveWindow()
4) 위치와 크기 고정
  - WM_MOVE	(메인 윈도우와 함께 다이얼로그도 이동)
  - WM_SIZE    	(메인 윈도우 크기 고정)

<3단계>
  - 최대화 버튼 비활성화: CreateWindow의 WS_OVERLAPPEDWINDOW 수정

[파일 열기 및 저장]
* 메뉴 -> WM_COMMAND에서 발생 -> LOWORD(wParam)아이디 입력됨

* 파일 저장 및 열기 다이얼로그의 역할
  - 사용자 인터페이스
  - 실제 저장은 C함수, C++함수, Win32 API 사용

* 파일 열기 다이얼로그 설정과 생성
  - 고정된 코드
  - OPENFILENAME  셋팅 -> <Commdlg.h>
  - GetOpenFileName() 호출
  - .nFilterIndex: 파일 인덱스 (*1부터 시작)

[툴 구조 응용하기]
* 메인 윈도우 외에 일반 윈도우를 생성하는 순서
1) 메인 윈도우 외에 생성하려는 윈도우를 설정하고 윈도우 프로시져를 등록

2) 윈도우 클래스와 프로스져 등록
  - 기존 윈도우 클래스 활용
  - 기존 프로시져 활용

3) 윈도우 화면 조절 및 생성
  - WM_CREATE에서 크기 설정 및 생성
  - MoveWindow() 사용
  + 전체 화면 해상도 구하기
	GetSystemMetrics(SM_CXSCREEN)
	GetSystemMetrics(SM_CYSCREEN)
  + 비율에 따른 윈도우 크기 구하기
	75%의 길이 = 전체 길이 * 0.75
  + 윈도우 생성과 위치 설정
	- CreateWindow()
	   WS_PRPUP|WS_CAPTION|
	   WS_THICKFRAME|WS_VISIBLE

4) 메뉴 다이얼로그 생성 및 이동
  - CreateDialog()
  - MoveWindow()

5) 다이얼로그 해제
  - DestroyWindow()